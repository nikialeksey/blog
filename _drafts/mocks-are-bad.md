---
layout: post
title: "Моки это плохо. Очень."
image: 
description: "Почему популярные фреймворки для создания моков портят вам код, и как обходится без моков в тестировании"
tags: 
  - testing
  - mocks
  - fakes
---

Часто используете [Mockito](https://site.mockito.org/) или подобные фреймворки
для написания своих тестов? Тогда я знаю, как улучшить ваши тесты! 

<!--more-->

Для начала разберемся, что такое моки. Если просто моки - это объекты, которые
создаются вызовом `Mockito.mock`:
```java
final Email email = Mockito.mock(Email.class);
```
Получившийся объект реализует интерфейс Email, только пока все его методы ничего
не делают. Такому объекту можно задавать поведение:
```java
Mockito.when(
    email.html()
).thenReturn(
    "<p>Hello, Fakes!</p>"
);
```
И, затем, можно тестировать объект, который использует письмо для отображения:
```java
assertThat(
    new EmailPage(email).html(), 
    IsEqual.equalTo(
        "<html><body><p>Hello, Fakes!</p></body><html>"
    )
);
```

То есть, если мы используем моки, то при написании тестов нам придется думать
о реализации тестируемого класса --- это так называемое 
[тестирование белого ящика](https://en.wikipedia.org/wiki/White-box_testing). 
В приведенном выше примере при тестировании
`EmailPage` нам понадобилось знание того, что в реализации метода 
`EmailPage#html` вызывался метод `Email#html`, и поведение этого метода мы
определили в моке. Плохо здесь вот что: при изменении реализации 
`EmailPage#html` с сохранением контракта (то есть так, что реализация 
изменилась, а поведение нет) вам, скорее всего, потребуется так же изменить 
тест, потому что он опирается на старую реализацию, потому что моки в нем были 
описаны для старой реализации. 

